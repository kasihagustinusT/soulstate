import { CodeBlock } from '../components/code-block';
import { Callout } from '../components/callout';

# Getting Started

Welcome to SoulState! This guide will walk you through creating a store and connecting it to a React component. By the end, you'll see how SoulState enables surgical, high-performance state updates with minimal boilerplate.

## 1. Installation

First, install SoulState using your preferred package manager.

<CodeBlock language="bash" code={`npm install soulstate`} />

SoulState has no external dependencies, keeping your bundle size lean.

## 2. Creating a Store

A "store" is an object that holds your state and the functions to update it. You create one with the `createStore` function.

Let's define a simple counter store in a file named `store.ts`.

<CodeBlock language="typescript" code={`
import { createStore } from 'soulstate';

// Define the shape of your state and actions
export interface CounterState {
  count: number;
  increment: () => void;
  decrement: () => void;
}

// Create the store
export const useCounterStore = createStore<CounterState>((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
}));
`} />

<Callout type="info" title="What's happening here?">
  `createStore` takes a single argument: an "initializer" function. This function receives `set`, a method to update the store's state. It should return the initial state of your store, including any action functions.
</Callout>

## 3. Connecting to React Components

To use the store in a React component, import the `useStore` hook from `soulstate` and the store you just created.

The `useStore` hook requires two arguments:
1.  The store you want to use (`useCounterStore`).
2.  A **selector function** that picks a piece of state.

<CodeBlock language="tsx" code={`
import { useStore } from 'soulstate';
import { useCounterStore, CounterState } from './store';

// A selector to get the count
const selectCount = (state: CounterState) => state.count;

// A selector to get the actions
const selectActions = (state: CounterState) => ({
  increment: state.increment,
  decrement: state.decrement,
});

export function Counter() {
  // This component subscribes ONLY to the 'count' value
  const count = useStore(useCounterStore, selectCount);
  
  // This component subscribes to the action functions
  // Since functions are stable, this hook will never cause a re-render
  const { increment, decrement } = useStore(useCounterStore, selectActions);

  return (
    <div>
      <h1>Count: {count}</h1>
      <button onClick={increment}>+1</button>
      <button onClick={decrement}>-1</button>
    </div>
  );
}
`} />

### The Power of Selectors

Notice we used two separate `useStore` calls. This is the key to SoulState's performance.

- The first call, `useStore(useCounterStore, selectCount)`, makes the `Counter` component listen **only** to changes in the `count` property.
- The second call subscribes to the actions. Since `increment` and `decrement` are functions that don't change, this subscription will not trigger re-renders.

This fine-grained subscription model ensures your component only re-renders when the exact data it needs has changed, eliminating wasted renders and keeping your UI fast and responsive.

<Callout type="warning" title="Anti-Pattern: Selecting the Whole State">
Avoid selecting the entire state object in a single hook:
`const state = useStore(useCounterStore, state => state);`
This will cause the component to re-render on **every** state change, defeating the purpose of selector-based subscriptions.
</Callout>
