import { CodeBlock } from '../../components/code-block';
import { Callout } from '../../components/callout';

# Batching

In a state management library, "batching" is the process of grouping multiple state updates into a single, atomic operation. This is critical for both performance and UI consistency. SoulState performs batching automatically, so you get these benefits for free.

## Automatic Batching with Microtasks

Whenever you call `set`, SoulState does not immediately notify its subscribers. Instead, it schedules a notification to run in a **microtask**.

A microtask is a short function that runs after the current JavaScript task is finished, but before the browser has a chance to repaint the screen.

<CodeBlock language="typescript" code={`
// store.ts
export const useCountStore = createStore(set => ({
  count: 0,
  inc: () => set(s => ({ count: s.count + 1 })),
  dec: () => set(s => ({ count: s.count - 1 })),
}));

// component.tsx
import { useCountStore } from './store';

function MyComponent() {
  const { inc, dec } = useStore(useCountStore, s => ({ inc: s.inc, dec: s.dec }));

  const handleUpdate = () => {
    // These two 'set' calls happen in the same event loop task.
    inc(); // Schedules a notification.
    inc(); // Does NOT schedule a new notification, as one is already pending.
  };

  // Because of automatic batching, the component will only re-render ONCE,
  // with the final state.
  return <button onClick={handleUpdate}>Update</button>;
}
`} />

### Why is this important?

1.  **Performance**: It dramatically reduces the number of re-renders. If you have 10 state updates in a single click handler, your components will only render once with the final state, not 10 times.
2.  **Prevents "Tearing"**: Tearing is a UI inconsistency where different components show different state values from the same update batch because they rendered at different times. By batching all notifications and rendering with the final state, SoulState ensures your entire UI is always consistent.

## Update Timeline Diagram

Hereâ€™s a visual representation of how SoulState batches updates within a single JavaScript event loop tick.

```mermaid
sequenceDiagram
    participant User
    participant Component
    participant SoulState
    participant MicrotaskQueue as "Microtask Queue"
    participant React

    User->>Component: Clicks a button
    Component->>SoulState: set({ count: 1 })
    SoulState->>MicrotaskQueue: Schedules notify()
    Component->>SoulState: set({ count: 2 })
    Note right of SoulState: Notification already scheduled, do nothing.
    
    Note over Component, React: --- End of current JS task ---

    MicrotaskQueue->>SoulState: Executes notify()
    SoulState->>React: Triggers re-render with final state ({ count: 2 })
    React->>Component: Re-renders with count = 2
```

<Callout type="success" title="React 18+ Compatibility">
SoulState's microtask batching works perfectly with React's own internal batching and the `useSyncExternalStore` hook, ensuring robust and predictable behavior in all versions of React 18 and beyond.
</Callout>

## Manual Batching (Legacy / Advanced)

While automatic batching covers 99% of use cases, you might encounter scenarios where you need to manually control the batching boundary, especially when dealing with updates outside of the normal React event loop (e.g., in a `setTimeout` or a WebSocket message handler).

For these rare cases, you can use the `batch` utility. However, due to the reliability of `queueMicrotask`, this is often unnecessary in the current version of SoulState. The core `set` function's automatic batching is the preferred and documented approach.

The `batch` utility was more relevant in older architectures that did not use microtask-based scheduling. In modern SoulState, its use is relegated to highly specific edge cases, such as synchronizing multiple distinct stores.
