import { CodeBlock } from '../../components/code-block';
import { Callout } from '../../components/callout';

# Selectors

Selectors are the cornerstone of SoulState's design and performance. A selector is a function that takes the entire state object and returns a smaller, specific piece of it.

**The `useStore` hook is selector-driven.** This means your components subscribe to state changes *through* selectors.

<CodeBlock language="tsx" code={`
import { useStore } from 'soulstate/react';
import { useBearStore } from './store';

// This is a selector function.
// It takes the full state and returns only the 'bears' number.
const bearSelector = (state) => state.bears;

function BearCounter() {
  // The component subscribes to the store VIA the selector.
  const bears = useStore(useBearStore, bearSelector);

  // This component will ONLY re-render when 'state.bears' changes.
  // Changes to any other part of the store will be ignored.
  return <div>{bears} around here...</div>;
}
`} />

## Why Selectors are Essential for Performance

Without selectors, components would have to subscribe to the entire state object. This would cause them to re-render every time *any* part of the state changes, leading to many unnecessary and expensive renders.

Selectors allow you to create a "virtual" subscription to a specific slice of the state.

<Callout type="success" title="The Golden Rule of Selectors">
  A component should only select the minimal amount of state it needs to render. The more granular your selectors, the fewer re-renders your application will have.
</Callout>

## Selecting Multiple Items

A common pattern is to select multiple values for a single component. The naive approach can lead to performance issues.

### The Problem: New Object References

<CodeBlock language="tsx" code={`
// ⚠️ ANTI-PATTERN
// This selector creates a new object { bears, increase } every time it runs.
// Because the object reference is always new, the default equality check fails,
// and the component re-renders on EVERY state change.
const { bears, increase } = useStore(useBearStore, (state) => ({
  bears: state.bears,
  increase: state.increase,
}));
`} />

### The Solution: `shallow` Equality

To solve this, you must provide an alternative equality function that compares the *contents* of the object, not its reference. SoulState provides the `shallow` function for this exact purpose.

<CodeBlock language="tsx" code={`
import { useStore, shallow } from 'soulstate/react';

// ✅ BEST PRACTICE
// By providing 'shallow' as the third argument, we tell useStore
// to compare the values of 'bears' and 'increase' inside the object.
// The component now only re-renders if 'state.bears' or 'state.increase' changes.
const { bears, increase } = useStore(
  useBearStore,
  (state) => ({
    bears: state.bears,
    increase: state.increase,
  }),
  shallow
);
`} />

## Memoizing Selectors for Expensive Computations

If your selector performs an expensive computation (e.g., filtering a large array), you should memoize it to prevent re-running the computation on every render.

While SoulState doesn't ship with a `createSelector` utility out of the box (to keep the core minimal), you can easily use libraries like `reselect` or a simple custom memoization hook.

### Example with a basic memoization utility:

<CodeBlock language="typescript" code={`
import { useStore } from 'soulstate/react';
import { useMemo } from 'react';

// A simple memoization utility
const memoize = (fn) => {
  let lastArgs = [];
  let lastResult;
  return (...args) => {
    if (args.every((arg, i) => arg === lastArgs[i])) {
      return lastResult;
    }
    lastArgs = args;
    lastResult = fn(...args);
    return lastResult;
  };
};

const createSelector = (inputSelectors, combiner) => {
  const memoizedCombiner = memoize(combiner);
  return (state) => {
    const inputs = inputSelectors.map(selector => selector(state));
    return memoizedCombiner(...inputs);
  }
}

// --- In your component ---

// Input selectors
const selectItems = (state) => state.items;
const selectFilter = (state) => state.filter;

// Memoized selector
const selectVisibleItems = useMemo(() => 
  createSelector(
    [selectItems, selectFilter],
    (items, filter) => {
      console.log('Running expensive filter...');
      return items.filter(item => item.name.includes(filter));
    }
  ), 
[]);

function VisibleItems() {
  const visibleItems = useStore(useItemStore, selectVisibleItems);
  // ... render items
}
`} />

<Callout type="info" title="When to Memoize">
You only need to memoize selectors if they are performing computationally expensive work. For simple property access (`state => state.prop`), memoization is unnecessary overhead.
</Callout>
