---
title: Modular Stores
sidebar_label: Modular Stores
---

import CodeBlock from '@theme/CodeBlock';
import { Admonition } from '@site/src/components/Admonition';

# Guides: Modular Stores

As your application grows, managing all state within a single, monolithic store can become unwieldy. SoulState encourages a modular approach, allowing you to break down your application's state into smaller, independent, and domain-specific stores. This enhances maintainability, improves team collaboration, and can lead to better performance.

## Why Modularize?

1.  **Separation of Concerns**: Each store focuses on a specific domain (e.g., authentication, user profiles, shopping cart, UI settings).
2.  **Improved Readability and Maintainability**: Smaller files are easier to understand, debug, and maintain.
3.  **Reduced Cognitive Load**: Developers only need to understand the state relevant to the feature they are working on.
4.  **Enhanced Scalability**: Easier to manage state in large teams and complex applications.
5.  **Targeted Updates**: While SoulState's core batching and selectors already optimize performance, modular stores can further reduce the scope of state changes, making it clearer which parts of the application are affected.

## How to Create Modular Stores

Creating modular stores in SoulState is straightforward: simply define multiple `createStore` instances, each in its own file, representing a distinct domain.

<CodeBlock language="typescript">
{`// stores/authStore.ts
interface AuthState {
  isAuthenticated: boolean;
  user: { id: string; name: string; email: string } | null;
  login: (credentials: any) => Promise<void>;
  logout: () => void;
}

export const useAuthStore = createStore<AuthState>((set) => ({
  isAuthenticated: false,
  user: null,
  login: async (credentials) => {
    // Simulate API call
    const response = await new Promise(resolve => setTimeout(() => resolve({ id: '123', name: 'John Doe', email: 'john@example.com' }), 500));
    set({ isAuthenticated: true, user: response as any });
  },
  logout: () => set({ isAuthenticated: false, user: null }),
}));

// stores/themeStore.ts
interface ThemeState {
  theme: 'light' | 'dark';
  toggleTheme: () => void;
}

export const useThemeStore = createStore<ThemeState>((set) => ({
  theme: 'light',
  toggleTheme: () => set(state => ({ theme: state.theme === 'light' ? 'dark' : 'light' })),
}));
`}
</CodeBlock>

## Consuming Modular Stores in Components

In your React components, you simply import and use the specific store(s) you need, leveraging `useStore` with appropriate selectors.

<CodeBlock language="tsx">
{`import { useStore } from 'soulstate/react';
import { useAuthStore } from '../stores/authStore';
import { useThemeStore } from '../stores/themeStore';

function Header() {
  const isAuthenticated = useStore(useAuthStore, (state) => state.isAuthenticated);
  const user = useStore(useAuthStore, (state) => state.user);
  const logout = useStore(useAuthStore, (state) => state.logout);

  const theme = useStore(useThemeStore, (state) => state.theme);
  const toggleTheme = useStore(useThemeStore, (state) => state.toggleTheme);

  return (
    <header style={{ background: theme === 'dark' ? '#333' : '#eee', color: theme === 'dark' ? '#eee' : '#333' }}>
      {isAuthenticated ? (
        <>
          <span>Welcome, {user?.name}</span>
          <button onClick={logout}>Logout</button>
        </>
      ) : (
        <span>Please log in</span>
      )}
      <button onClick={toggleTheme}>Toggle Theme ({theme})</button>
    </header>
  );
}
`}
</CodeBlock>

## Inter-Store Communication

While stores should ideally be independent, sometimes one store needs to react to changes in another.

### Option 1: Pass Actions as Arguments

The simplest way is to pass an action from one store to another as an argument.

<CodeBlock language="typescript">
{`// stores/notificationStore.ts
export const useNotificationStore = createStore((set) => ({
  notifications: [],
  addNotification: (message: string) => set(state => ({
    notifications: [...state.notifications, { id: Date.now(), message }]
  })),
}));

// stores/authStore.ts (modified)
export const useAuthStore = createStore((set) => ({
  // ... other state ...
  login: async (credentials) => {
    // ... login logic ...
    useNotificationStore.getState().addNotification('Login successful!');
    set({ isAuthenticated: true, user: { id: '1', name: 'User' } });
  },
}));
`}
</CodeBlock>

### Option 2: Subscribe to Another Store

A store can subscribe to another store's changes using `store.subscribe()`. This is useful for more complex reactions or derived state.

<CodeBlock language="typescript">
{`// stores/analyticsStore.ts
export const useAnalyticsStore = createStore((set) => ({
  loginCount: 0,
  // ...
}));

// In an initialization file or effect:
useAuthStore.subscribe(
  (state) => state.isAuthenticated,
  (isAuthenticated, prevIsAuthenticated) => {
    if (isAuthenticated && !prevIsAuthenticated) {
      useAnalyticsStore.getState().set(state => ({ loginCount: state.loginCount + 1 }));
    }
  }
);
`}
</CodeBlock>

<Admonition type="caution" title="Avoid Circular Dependencies">
  <p>When stores interact, be mindful of circular dependencies. Design your stores to be as independent as possible, and use explicit communication channels (like passing actions or subscribing) rather than direct imports that could lead to cycles.</p>
</Admonition>

## Conclusion

Modular stores in SoulState provide a clean, scalable, and efficient way to manage complex application state. By organizing your state logically and using clear communication patterns, you can build robust applications that are easy to understand and maintain.
