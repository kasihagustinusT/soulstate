---
title: Getting Started
sidebar_label: Getting Started
sidebar_position: 1
---

import { Admonition } from '@site/src/components/Admonition';
import CodeBlock from '@theme/CodeBlock';

# Getting Started

Welcome to SoulState! This guide will walk you through creating a store and connecting it to a React component. By the end, you'll see how SoulState enables surgical, high-performance state updates with minimal boilerplate.

## 1. Installation

First, install SoulState using your preferred package manager.

<CodeBlock language="bash">
{`npm install soulstate`}
</CodeBlock>

SoulState has no external dependencies, keeping your bundle size lean.

## 2. Creating a Store

A "store" is an object that holds your state and the functions to update it. You create one with the `createStore` function.

Let's define a simple counter store in a file named `store.ts`.

<CodeBlock language="typescript">
{`import { createStore } from 'soulstate';

// Define the shape of your state and actions
export interface CounterState {
  count: number;
  increment: () => void;
  decrement: () => void;
}

// Create the store
export const useCounterStore = createStore<CounterState>((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
}));
`}
</CodeBlock>

<Admonition type="info" title="What's happening here?">
  <p><code>createStore</code> takes a single argument: an "initializer" function. This function receives <code>set</code>, a method to update the store's state. It should return the initial state of your store, including any action functions.</p>
</Admonition>

## 3. Connecting to React Components

To use the store in a React component, import the `useStore` hook from `soulstate` and the store you just created.

The `useStore` hook requires two arguments:
1.  The store you want to use (`useCounterStore`).
2.  A **selector function** that picks a piece of state.

<CodeBlock language="tsx">
{`import { useStore } from 'soulstate';
import { useCounterStore, CounterState } from './store';

// A selector to get the count
const selectCount = (state: CounterState) => state.count;

// A selector to get the actions
const selectActions = (state: CounterState) => ({
  increment: state.increment,
  decrement: state.decrement,
});

export function Counter() {
  // This component subscribes ONLY to the 'count' value
  const count = useStore(useCounterStore, selectCount);
  
  // This component subscribes to the action functions
  // Since functions are stable, this hook will never cause a re-render
  const { increment, decrement } = useStore(useCounterStore, selectActions);

  return (
    <div>
      <h1>Count: {count}</h1>
      <button onClick={increment}>+1</button>
      <button onClick={decrement}>-1</button>
    </div>
  );
}
`}
</CodeBlock>

### The Power of Selectors

Notice we used two separate `useStore` calls. This is the key to SoulState's performance.

- The first call, `useStore(useCounterStore, selectCount)`, makes the `Counter` component listen **only** to changes in the `count` property.
- The second call subscribes to the actions. Since `increment` and `decrement` are functions that don't change, this subscription will not trigger re-renders.

This fine-grained subscription model ensures your component only re-renders when the exact data it needs has changed, eliminating wasted renders and keeping your UI fast and responsive.

<Admonition type="danger" title="Anti-Pattern: Selecting the Whole State">
  <p>Avoid selecting the entire state object in a single hook:
  <code>const state = useStore(useCounterStore, state => state);</code>
  This will cause the component to re-render on <strong>every</strong> state change, defeating the purpose of selector-based subscriptions.</p>
</Admonition>
